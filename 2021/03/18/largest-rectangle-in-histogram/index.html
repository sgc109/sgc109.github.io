<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>히스토그램에서 가장 큰 직사각형 - Sungho&#039;s Blog</title><meta description="히스토그램에서 가장 큰 직사각형(Largest Rectangle in Histogram)이라는 문제를 푸는 다양한 방법에 대해 알아보자."><meta property="og:type" content="blog"><meta property="og:title" content="히스토그램에서 가장 큰 직사각형"><meta property="og:url" content="http://sgc109.github.io/2021/03/18/largest-rectangle-in-histogram/"><meta property="og:site_name" content="Sungho&#039;s Blog"><meta property="og:description" content="히스토그램에서 가장 큰 직사각형(Largest Rectangle in Histogram)이라는 문제를 푸는 다양한 방법에 대해 알아보자."><meta property="og:locale" content="en_US"><meta property="og:image" content="http://sgc109.github.io/images/largest-rectangle-in-histogram/thumbnail.png"><meta property="article:published_time" content="2021-03-18T12:15:26.000Z"><meta property="article:modified_time" content="2022-07-23T13:35:53.455Z"><meta property="article:author" content="Sungho Hwang"><meta property="article:tag" content="CS General"><meta property="article:tag" content="Algorithms"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/largest-rectangle-in-histogram/thumbnail.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://sgc109.github.io/2021/03/18/largest-rectangle-in-histogram/"},"headline":"Sungho's Blog","image":["http://sgc109.github.io/images/largest-rectangle-in-histogram/thumbnail.png"],"datePublished":"2021-03-18T12:15:26.000Z","dateModified":"2022-07-23T13:35:53.455Z","author":{"@type":"Person","name":"Sungho Hwang"},"description":"히스토그램에서 가장 큰 직사각형(Largest Rectangle in Histogram)이라는 문제를 푸는 다양한 방법에 대해 알아보자."}</script><link rel="canonical" href="http://sgc109.github.io/2021/03/18/largest-rectangle-in-histogram/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono" type="text/css"><link href="//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css" rel="stylesheet" type="text/css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-172530521-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-172530521-1');</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="alternate" href="/rss2.xml" title="Sungho's Blog" type="application/rss+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/sungho.png" alt="Sungho&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/sgc109"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="/images/largest-rectangle-in-histogram/thumbnail.png" alt="히스토그램에서 가장 큰 직사각형"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2021-03-18T12:15:26.000Z" title="2021-03-18T12:15:26.000Z">2021-03-18</time><span class="level-item"><a class="link-muted" href="/categories/General/">General</a><span> / </span><a class="link-muted" href="/categories/General/Algorithms/">Algorithms</a></span></div></div><h1 class="title is-3 is-size-4-mobile">히스토그램에서 가장 큰 직사각형</h1><div class="content"><p><code>히스토그램에서 가장 큰 직사각형(Largest Rectangle in Histogram)</code>이라는 문제를 푸는 다양한 방법에 대해 알아보자.</p>
<a id="more"></a>
<p>이 문제는 임의의 높이를 가진 $N$개의 막대가 주어질 때, 막대 안에 포함되는 직사각형 중 가장 넓이가 큰 직사각형의 넓이를 구하는 유명한 문제인데, 푸는 방법이 다양하다는 점에서 재미있다.</p>
<p>유명한 문제이기 때문에 다양한 온라인 저지 사이트에서 이 문제가 올라와 있는 것을 볼 수 있다. 문제마다 입력으로 주어지는 값들의 조건은 조금씩 다르기도 하다.</p>
<p>여기서는 <a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">LeetCode 84. Largest Rectangle in Histogram</a> 를 기준으로 설명하겠다.</p>
<p>본 글에서는 이 문제를 해결하는 5가지 풀이에 대해 알아볼 것이다.</p>
<h1>풀이</h1>
<h2 id="브루트포스">브루트포스</h2>
<p>시간복잡도 : $O(N^3)$</p>
<p>우선 알고리즘의 효율성에 대해 생각하지 말고 가장 무식한 방법을 떠올려보자. 만들 수 있는 모든 직사각형을 만들어 직사각형의 넓이를 구하면 답을 계산할 수 있을 것이다. 모든 직사각형은 자신의 가장 왼쪽에 위치한 막대와 가장 오른쪽에 위치한 막대가 있을 것이다. 그 직사각형의 높이는 위치상 직사각형에 포함되는 막대들의 높이 중 가장 낮은 막대의 높이가 될 것이다. 그렇기 때문에 모든 막대 쌍 l, r 에 대해 l 부터 r 까지의 막대 중 가장 높이가 낮은 막대의 높이를 계산한 뒤 직사각형의 넓이를 계산해 답을 갱신하면 문제를 해결할 수 있다.</p>
<p>모든 막대 쌍을 순회하는 데 $O(N^2)$ 의 시간이 소요되고, 각 막대 쌍에 대해 최대 높이를 구하는데 $O(N)$ 의 시간이 소요되므로, 총 $O(N^3)$ 의 시간이 소요된다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_H = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = heights.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> minH = MAX_H + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">                    minH = min(minH, heights[k]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = max(ans, (j - i + <span class="number">1</span>) * minH);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="최적화된-브루트포스">최적화된 브루트포스</h2>
<p>시간복잡도 : $O(N^2)$</p>
<p>앞서 설명한 알고리즘을 다시 한 번 보자. 첫번째 반복문에서 왼쪽 막대를 정하고, 두번째 반복문에서 오른쪽 막대를 정하게 된다. 그런데 직사각형의 높이를 찾기위한 세번째 반복문을 잘 보면, 오른쪽 막대를 오른쪽으로 한 칸씩 이동할 때마다 매번 맨 왼쪽 막대부터 처음부터 확인하는 것을 알 수 있다. 굳이 이미 봤던 막대를 다시 볼 필요가 없기 때문에 두번째와 세번째 반복문을 하나의 반복문으로 합칠 수가 있다. 그리하여 시간복잡도는 $O(N^2)$ 이 된다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = heights.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minH = heights[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; N; j++) &#123;</span><br><span class="line">                minH = min(minH, heights[j]);</span><br><span class="line">                ans = max(ans, (j - i + <span class="number">1</span>) * minH);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="세그먼트-트리">세그먼트 트리</h2>
<p>시간복잡도 : $O(NlogH)$</p>
<p>이번에는 문제를 다르게 한 번 정의해 보자. 앞에서는 양쪽 막대의 가능한 쌍을 모두 확인했기 때문에 그것만으로도 $O(N^2)$ 의 시간복잡도가 소요되었다.</p>
<p>하지만 잘 생각해보면 히스토그램 안에 있는 직사각형들은 높이를 가지고, 직사각형 안에는 항상 직사각형과 같은 높이를 가지는 막대가 있을 것이다.</p>
<p>그렇기 때문에 이번에는 높이가 되는 막대를 정하고 그 높이를 가지는 직사각형 중 가장 큰 직사각형을 찾아보자. 즉, 정해진 높이를 가질 수 있는 가장 왼쪽 막대와 가장 오른쪽 막대를 찾아보자.</p>
<p>문제를 단순화하기 위해 왼쪽과 오른쪽 중에 일단 왼쪽부터 보자.</p>
<p>즉, 각 막대에 대해 해당 막대의 높이로 직사각형을 만들 수 있는 가장 왼쪽 막대의 인덱스를 찾아보자.</p>
<p>살짝 다르게 말해서, (1) 나보다 왼쪽에 있는 막대 중, (2) 나보다 낮은 막대 중에 (3) 가장 오른쪽에 있는 막대를 찾아보자. 그럼 그 막대의 오른쪽 막대가 현재 보는 기둥의 높이로 만들 수 있는 직사각형의 가장 왼쪽 막대가 된다.</p>
<p>그럼 maxIdx 라는 배열을 만들어 maxIdx[i] 를 i의 높이를 가지는 막대들의 index 중 최대값이라고 정의해보자.</p>
<p>막대는 왼쪽부터 오른쪽으로 봐 나갈 것이고, 막대를 볼 때마다 해당 막대의 높이 정보로 maxIdx 를 업데이트한다고 하면, 결국 1번 조건은 자동으로 만족되고, 2번과 3번 조건은 <strong>RMQ(Range Maximum Query)</strong> 를 통해 로그 시간으로 계산할 수 있다. 쿼리를 수행하는 범위(range)는 [0, 직사각형 높이 - 1] 이 된다. 여기서 주의해야할 점은, 문제에서 주어지는 막대의 최대 높이가 너무 커서 세그먼트 트리를 구축할 수 없는 경우다. 하지만, 막대의 개수는 충분히 작을 것이기 때문에(대부분의 경우는 $10^5$ 이하) 좌표 압축을 수행하면 된다. 여기서는 막대의 최대 높이가 $10^4$ 라고 가정하겠다. 아무튼 이렇게 하여 막대의 최대 높이가 $H$ 일 때, $O(NlogH)$ 의 시간복잡도로 각 막대를 높이로 삼는 직사각형의 왼쪽 끝 막대를 찾을 수 있었다.</p>
<p>이번엔 오른쪽 끝 막대를 찾아볼 텐데, 사실 잘 생각해보면 막대의 순서를 뒤집어서 같은 일을 하면 된다.</p>
<p>여기서 오른쪽 끝 막대의 경우 계산하고 난 뒤에 배열과 인덱스들을 다시 뒤집어 주는 것을 잊으면 안된다.</p>
<p>결론적으로, 세그먼트 트리를 구축하는데 $O(H)$ 의 시간이 걸리고 각 높이 별 왼쪽 끝 막대와 오른쪽 끝 막대의 인덱스를 찾는데 각각 $O(NlogH)$ 의 시간 복잡도가 걸려서, 전체 시간 복잡도는 $O(H + NlogH)$ 다. 물론, 여기서 $H$ 가 커진다면 $O(NlogN)$ 으로 좌표압축을 해야하지만, 지금은 $H &lt; N$ 이기 때문에, 무시해도 될 것이다. 즉, 최종 시간복잡도는 $O(NlogH)$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> MAX_H = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">int</span> maxRange = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lBorders;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rBorders;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution() &#123;</span><br><span class="line">        <span class="keyword">while</span>(maxRange &lt; MAX_H) maxRange *= <span class="number">2</span>;</span><br><span class="line">        tree = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(maxRange * <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        pos += maxRange;</span><br><span class="line">        tree[pos] = max(tree[pos], val);</span><br><span class="line">        <span class="keyword">for</span>(; pos &gt; <span class="number">1</span>; pos /= <span class="number">2</span>) &#123;</span><br><span class="line">            tree[pos / <span class="number">2</span>] = max(tree[pos], tree[pos ^ <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        l += maxRange, r += maxRange;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; l &lt;= r; l /= <span class="number">2</span>, r /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l &amp; <span class="number">1</span>) ret = max(ret, tree[l++]);</span><br><span class="line">            <span class="keyword">if</span>(~r &amp; <span class="number">1</span>) ret = max(ret, tree[r--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; borders)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++) &#123;</span><br><span class="line">            borders[i] = query(<span class="number">0</span>, heights[i] - <span class="number">1</span>);</span><br><span class="line">            update(heights[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = heights.size();</span><br><span class="line">        lBorders = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">        rBorders = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        solve(heights, lBorders);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; reversed = heights;</span><br><span class="line">        reverse(begin(reversed), end(reversed));</span><br><span class="line">        tree = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span> * maxRange, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        solve(reversed, rBorders);</span><br><span class="line">        reverse(begin(rBorders), end(rBorders));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) rBorders[i] = N - rBorders[i] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            ans = max(ans, (rBorders[i] - lBorders[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="분할정복-그리디">분할정복 + 그리디</h2>
<p>시간복잡도 : $O(NlogN)$</p>
<p>재귀적으로 문제를 해결해보자. 일단 $N$ 개의 막대로 이루어진 임의의 히스토그램이 주어졌을 때 막대들을 절반으로 나누어보자. 히스토그램 내 직사각형은 3가지 경우 중 하나일 것이다. (1) 왼쪽 절반에 있거나, (2) 오른쪽 절반에 있거나, (3) 사이에 걸쳐있거나. 그럼 (1)번과 (2)번의 경우는 결국 일부 막대에 대해 완전히 동일한 문제를 푸는 것이 되기 때문에 재귀 호출로 간단히 해결할 수 있다. 그럼 (3)번의 경우만 계산해주면 문제를 해결할 수 있다. 풀이2 에서 썼던 무식한 방법으로도 계산할 수 있지만, 이러면 애초에 풀이2 로 푸는것보다도 비효율적이다. 여기서는 잘 생각해보면 다음과같이 그리디하게 $O(N)$ 으로 계산할 수가 있다.</p>
<p>왼쪽 끝 막대와 오른쪽 끝 막대를 2개의 포인터로 가리키게 해보자. 이 두 포인터를 가장 가운데 있는 두 막대를 가리키도록 초기화 하고 둘을 바깥쪽으로 하나씩 이동시키면서 답을 계산할 것이다. 매 단계마다 두 포인터 중에서 다음 막대의 높이가 더 높은 포인터를 이동시킨다. 그리고 새로 가리킨 막대의 높이로 직사각형의 높이를 갱신한다. 이렇게 했을 때 답을 구할 수 있다는 것을 증명해보자.</p>
<p>위의 알고리즘의 경우 매 반복마다 두 포인터 중 하나를 한 칸 이동시키기 때문에 직사각형의 너비는 항상 1만큼 증가한다. 중요한 것은 높이의 변화인데, 다음 4가지 상황으로 나눌 수 있다.</p>
<ul>
<li>(1) 만약 왼쪽 포인터와 오른쪽 포인터 모두에 대해 다음 막대가 현재 직사각형의 높이보다 높거나 같은 높이인 경우</li>
</ul>
<p>어느 포인터를 이동시키든 직사각형의 높이는 그대로 유지되기 때문에 어느쪽을 이동시키든 상관없다.</p>
<ul>
<li>(2) 왼쪽 포인터와 오른쪽 포인터 모두, 다음 막대가 현재 직사각형의 높이보다 낮은 경우</li>
</ul>
<p>이 경우에는 높이가 최소한으로 줄어들 수 있는 선택을 해야한다. 직사각형의 높이는 직사각형을 이루는 모든 막대들의 높이 중 최소값이므로 이 경우 직사각형의 높이는 새로 가리키게 되는 막대의 높이로 변한다. 그렇기 때문에 다음 막대의 높이가 더 큰 포인터를 이동시킨다.</p>
<ul>
<li>(3) 한쪽은 직사각형의 높이보다 높거나 같고, 한쪽은 낮은 경우</li>
</ul>
<p>높거나 같은 쪽으로 움직여야 직사각형의 높이가 줄어들지 않고 그대로 유지되므로 높이가 높은 쪽 포인터를 움직인다.</p>
<p>위의 방법은 직사각형의 높이가 가능한한 천천히 감소하도록 너비를 1씩 증가시켰기 때문에, 가능한 모든 너비에서 가장 높은 높이로 답을 계산하게 된다.</p>
<p>다르게 생각해보면, 직사각형의 높이는 절대 커지지 않는다. 만약 변한다면 작아지기만 한다. 그렇기 때문에 위의 알고리즘은 높이가 유지되는 선에서 최대한 양쪽 포인터를 바깥쪽으로 늘리게 되고, 작아져야만 하는 경우에는 최소한으로만 감소시키기 때문에 결국엔 모든 막대들을 높이로 내림차순 정렬한 배열에서, 초기 높이에서부터 하나씩 작아지는 방향으로 직사각형의 높이를 변화시키게 된다.</p>
<p>이 때 재귀함수 호출의 깊이는 최대 $logN$ 번이고, 각 함수에서는 전체 막대기를 한 번씩 보게 된다. 그렇기 때문에 각 재귀 단계마다 전체 막대를 한 번씩 확인하는 셈이며, 그래서 전체 시간 복잡도는 $O(NlogN)$ 이다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_H = <span class="number">10000</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heights;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right) <span class="keyword">return</span> heights[left];</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = max(solve(left, mid), solve(mid + <span class="number">1</span>, right));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lpos = mid, rpos = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> minH = MAX_H + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= lpos &amp;&amp; rpos &lt;= right) &#123;</span><br><span class="line">            minH = min(&#123;minH, heights[lpos], heights[rpos]&#125;);</span><br><span class="line">            ans = max(ans, (rpos - lpos + <span class="number">1</span>) * minH);</span><br><span class="line">            <span class="keyword">if</span>(left == lpos) ++rpos;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(right == rpos) --lpos;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(heights[lpos - <span class="number">1</span>] &lt;= heights[rpos + <span class="number">1</span>]) ++rpos;</span><br><span class="line">            <span class="keyword">else</span> --lpos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;heights = heights;</span><br><span class="line">        <span class="keyword">return</span> solve(<span class="number">0</span>, heights.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="스택">스택</h2>
<p>시간복잡도 : $O(N)$</p>
<p>이번에도 마찬가지로 각 막대의 높이를 기둥으로 하는 직사각형의 가장 왼쪽 막대와 가장 오른쪽 막대를 찾아볼 것이다. 여기서는 스택을 사용하여 왼쪽 막대부터 보면서 하나씩 스택에 넣어줄 건데, 이 막대를 높이로하는 직사각형의 넓이의 계산은 나중으로 미루게 된다. 언제 계산하냐면, 이 막대보다 작은 높이의 막대를 발견하는 즉시 계산해준다. 왜냐하면 발견한 막대가 바로 앞서 스택에 넣었던 막대보다 오른쪽에 있으면서 높이가 작은 가장 왼쪽 막대이기 때문이다. 직사각형 넓이의 계산과 동시에 해당 막대는 스택에서 빼준다. 해당 막대를 높이로 하는 직사각형을 이미 계산했기 때문이다. 이런 방식으로 스택을 관리해주면 자연스레 스택에 있는 막대들은 높이가 오름차순으로 정렬된 상태가 되며, 스택 내에서 특정 막대의 바로 이전 막대는 그 막대보다 왼쪽에 있으면서 높이가 작은 가장 오른쪽 막대가 된다. 즉, 직사각형의 넓이를 계산해야 될 때, 왼쪽 막대(스택에서 최상위 막대 바로 이전에 저장된 막대), 높이(스택의 최상위 막대), 오른쪽 막대(현재 보는 막대)를 모두 상수 시간에 알 수 있다는 뜻이다. 즉, 모든 막대를 한 번 씩 보면서 각 막대가 딱 한 번 씩 스택에 들어갔다 나오며, 중간 중간 직사각형의 넓이를 상수시간에 계산하기 때문에 전체 시간 복잡도는 $O(N)$ 이 된다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        heights.push_back(<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        stk.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(stk.size() &gt; <span class="number">1</span> &amp;&amp; heights[i] &lt; heights[stk.top()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">int</span> left = left = stk.top();</span><br><span class="line">                ans = max(ans, (i - left - <span class="number">1</span>) * heights[mid]);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>사실 그림으로 설명하면 훨씬 이해가 쉬울텐데 그리기가 귀찮기 때문에 나중에 그림이 그리고 싶어졌을 때 첨부할 예정이다.</p>
<h1>문제 링크</h1>
<p>리트코드(LeetCode) - <a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">https://leetcode.com/problems/largest-rectangle-in-histogram/</a><br>
백준 온라인저지(BOJ) - <a href="https://www.acmicpc.net/problem/6549">https://www.acmicpc.net/problem/6549</a></p>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/CS-General/">CS General</a><a class="link-muted mr-2" rel="tag" href="/tags/Algorithms/">Algorithms</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5ea69e998fb91e001b32120c&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/07/23/tdd-review/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">[책 리뷰] 테스트 주도 개발</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/26/kubernetes-in-action-review/"><span class="level-item">[책 리뷰] Kubernetes in Action</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://sgc109.github.io/2021/03/18/largest-rectangle-in-histogram/';
            this.page.identifier = 'largest-rectangle-in-histogram';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'https-sgc109-github-io' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="is-flex" href="#"><span class="mr-2">1</span><span>풀이</span></a><ul class="menu-list"><li><a class="is-flex" href="#브루트포스"><span class="mr-2">1.1</span><span>브루트포스</span></a></li><li><a class="is-flex" href="#최적화된-브루트포스"><span class="mr-2">1.2</span><span>최적화된 브루트포스</span></a></li><li><a class="is-flex" href="#세그먼트-트리"><span class="mr-2">1.3</span><span>세그먼트 트리</span></a></li><li><a class="is-flex" href="#분할정복-그리디"><span class="mr-2">1.4</span><span>분할정복 + 그리디</span></a></li><li><a class="is-flex" href="#스택"><span class="mr-2">1.5</span><span>스택</span></a></li></ul></li><li><a class="is-flex" href="#"><span class="mr-2">2</span><span>문제 링크</span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/sungho.png" alt="Sungho&#039;s Blog" height="28"></a><p class="size-small"><span>&copy; 2023 Sungho Hwang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://sgc109.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: ''
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>